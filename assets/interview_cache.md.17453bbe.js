import{_ as e,o as a,c as o,Q as i}from"./chunks/framework.82e0a936.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/cache.md","filePath":"interview/cache.md","lastUpdated":1694189773000}'),t={name:"interview/cache.md"},p=i('<h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h2><ol><li><p><code>Expires</code> 设置时间，过期时间 <code>expires: Tue, 15 Oct 2019 13:30:54 GMT</code></p><p>通过本地时间和 expires 比较是否过期，如果过期了就去服务器请求，没有过期的话就直接使用本地的</p><p>缺点：本地时间可能会更改， 导致缓存出错</p></li><li><p><code>Cache-Control</code> HTTP1.1 中新增的</p><ul><li><p>max-age 最大缓存多少毫秒，列如 <code>Cache-Control: max-age=2592000</code></p></li><li><p>no-store (每次都要请求，就连协商缓存都不走)表示不进行缓存，缓存中不得存储任何关于客户端请求和服务端响应的内容。每次 由客户端发起的请求都会下载完整的响应内容。<code>Cache-Control: no-store</code></p></li><li><p>no-cache（默认值）表示不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称 为 do-notserve-from-cache-without-revalidation 更合适。浏览器默认开启的是 no-cache，其 实这里也可理解为开启协商缓存</p></li><li><p>public 和 private</p><p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念</p><p>当我们为资源设置了 pubilc，那么它既可以被浏览器缓存也可被代理服务器缓存。设置为</p><p>private 的时候，则该资源只能被浏览器缓存，其中默认值是 private。</p></li><li><p>max-age 和 s-maxage</p><p>s-maxage 只适用于供多用户使用的公共服务器上(如 CND cache)，并只对 public 缓存有效</p></li></ul></li></ol><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h2><blockquote><p>需要向服务器请求，如果没有过期，服务器会返回 304，</p></blockquote><ol><li><strong>ETag 和 If-None-Match 唯一标识</strong></li></ol><ul><li><p>服务器响应 ETag 值，浏览器携带的是 If-None-Match（携带的是上一次响应的 ETag），服务拿到这 If-None-Match 值后判断过期--&gt; 没有过期 304，并且返回 ETag</p><hr><p>二者的值都是服务器为每份资源分配的唯一标识字符串。</p><ul><li>浏览器请求资源，服务器会在响应报文头中加入 ETag 字段。资源更新的时候，服务端的</li></ul><p>ETag 值也随之更新</p><ul><li>浏览器再次请求资源，会在请求报文头中添加 If-None-Match 字段，它的值就是上次响应</li></ul><p>报文中的 ETag 值，服务器会对比 ETag 和 If-None-Match 的值是否一致。如果不一致，服务</p><p>器则接受请求，返回更新后的资源，状态码返回 200；如果一致，表明资源未更新，则返回</p><p>状态码 304，可继续使用本地缓存，值得注意的是此时响应头会加上 ETag 字段，即使它没</p><p>有变化</p><hr></li><li><p><strong>Last-Modified 和 If-Modified-Since 时间戳</strong> 缺点： 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，</p><p>If-Modified-Since 可查到的是秒级，这种修改无法判断</p></li></ul>',6),c=[p];function l(r,n,s,d,h,_){return a(),o("div",null,c)}const g=e(t,[["render",l]]);export{f as __pageData,g as default};
