import{_ as a,o as s,c as e,Q as l}from"./chunks/framework.82820f36.js";const m=JSON.parse('{"title":"2024.8.6","description":"","frontmatter":{},"headers":[],"relativePath":"study/2024.8.6.md","filePath":"study/2024.8.6.md","lastUpdated":1723977222000}'),t={name:"study/2024.8.6.md"},o=l(`<h1 id="_2024-8-6" tabindex="-1">2024.8.6 <a class="header-anchor" href="#_2024-8-6" aria-label="Permalink to &quot;2024.8.6&quot;">​</a></h1><h2 id="srcset" tabindex="-1">srcset <a class="header-anchor" href="#srcset" aria-label="Permalink to &quot;srcset&quot;">​</a></h2><p>srcset 属性用来指定多张图像，适应不同像素密度的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后</p><p>是像素密度的描述符。</p><p>(srcset)[<a href="https://www.ruanyifeng.com/blog/2019/06/responsive-images.html" target="_blank" rel="noreferrer">https://www.ruanyifeng.com/blog/2019/06/responsive-images.html</a>]</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#666666;">&lt;</span><span style="color:#4D9375;">img</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">srcset</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">foo-320w.jpg, foo-480w.jpg 1.5x, foo-640w.jpg 2x</span><span style="color:#C98A7D99;">&quot;</span></span>
<span class="line"><span style="color:#DBD7CAEE;">  </span><span style="color:#BD976A;">src</span><span style="color:#666666;">=</span><span style="color:#C98A7D99;">&quot;</span><span style="color:#C98A7D;">foo-640w.jpg</span><span style="color:#C98A7D99;">&quot;</span></span>
<span class="line"><span style="color:#666666;">/&gt;</span></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#999999;">&lt;</span><span style="color:#1E754F;">img</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">srcset</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">foo-320w.jpg, foo-480w.jpg 1.5x, foo-640w.jpg 2x</span><span style="color:#B5695999;">&quot;</span></span>
<span class="line"><span style="color:#393A34;">  </span><span style="color:#B07D48;">src</span><span style="color:#999999;">=</span><span style="color:#B5695999;">&quot;</span><span style="color:#B56959;">foo-640w.jpg</span><span style="color:#B5695999;">&quot;</span></span>
<span class="line"><span style="color:#999999;">/&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="map-和-set-的区别" tabindex="-1">map 和 set 的区别 <a class="header-anchor" href="#map-和-set-的区别" aria-label="Permalink to &quot;map 和 set 的区别&quot;">​</a></h2><p>map 是一个键值对的集合，而 set 是一个值的集合。</p><h2 id="https-是怎么保证数据安全的" tabindex="-1">https 是怎么保证数据安全的 <a class="header-anchor" href="#https-是怎么保证数据安全的" aria-label="Permalink to &quot;https 是怎么保证数据安全的&quot;">​</a></h2><p>通过证书，大概流程</p><p>1.客户端请求证书 2.服务端返回证书 3.客户端验证证书，并生成随机数 4.客户端使用证书加密随机数，发送给服务端 5.服务端使用证书解密随机数，验证通过后，返回数据</p><h2 id="怎么保证证书不被篡改-数字签名" tabindex="-1">怎么保证证书不被篡改（数字签名） <a class="header-anchor" href="#怎么保证证书不被篡改-数字签名" aria-label="Permalink to &quot;怎么保证证书不被篡改（数字签名）&quot;">​</a></h2><h3 id="什么是数字签名-签名的过程是什么" tabindex="-1">什么是数字签名？签名的过程是什么 <a class="header-anchor" href="#什么是数字签名-签名的过程是什么" aria-label="Permalink to &quot;什么是数字签名？签名的过程是什么&quot;">​</a></h3><p>签名的过程其实也很简单</p><ol><li>CA机构拥有非对称加密的私钥和公钥</li><li>CA对证书明文信息进行hash</li><li>对hash后的值用私钥加密，得到数字签名</li></ol><p>所以呢，总结一下：CA机构颁发的证书包含（证书内容的明文+签名）</p><h3 id="浏览器收到服务下发的证书之后-拿到证书明文和签名-怎么验证是否篡改了呢" tabindex="-1">浏览器收到服务下发的证书之后，拿到证书明文和签名，怎么验证是否篡改了呢？ <a class="header-anchor" href="#浏览器收到服务下发的证书之后-拿到证书明文和签名-怎么验证是否篡改了呢" aria-label="Permalink to &quot;浏览器收到服务下发的证书之后，拿到证书明文和签名，怎么验证是否篡改了呢？&quot;">​</a></h3><p>大家知道，私钥签名，公钥验签。证书里面的签名是CA机构用私钥签名的，所以我只要用CA机构的公钥验证一下签名不就好了，怎么验证呢？</p><ol><li>拿到证书里面明文的hash算法并对明文内容进行hash运算，得到A</li><li>用CA的公钥解密签名得到B</li><li>比较A 和 B，如果相等，说明没有被篡改，否则浏览器提示证书不可信</li></ol><h3 id="有没有发现一个问题-ca的公钥从哪里获取呢" tabindex="-1">有没有发现一个问题？CA的公钥从哪里获取呢 <a class="header-anchor" href="#有没有发现一个问题-ca的公钥从哪里获取呢" aria-label="Permalink to &quot;有没有发现一个问题？CA的公钥从哪里获取呢&quot;">​</a></h3><p>这个简单，CA权威机构本来也没多少个，所以，浏览器内部都内置了各大CA机构的公钥信息</p><h3 id="简单总结一下" tabindex="-1">简单总结一下 <a class="header-anchor" href="#简单总结一下" aria-label="Permalink to &quot;简单总结一下&quot;">​</a></h3><p>1.如果证书被篡改，浏览器就提示不可信，终止通信，如果验证通过，说明公钥没问题，一定没被篡改</p><p>2.公钥没被篡改，那浏览器生成的对称加密用的密钥用公钥加密发送给服务端，也只有服务端的私钥能解开，所以保证了 对称密钥不可能被截获，对称密钥没被截获，那双方的通信就一定是安全的</p><p>3.黑客依然可以截获数据包，但是全都是经过对称加密的密钥加密的，他也可以篡改，只是没有任何意义了,黑客也不会做吃力不讨好的事了</p><h2 id="webpack-常用插件有哪些" tabindex="-1">webpack 常用插件有哪些 <a class="header-anchor" href="#webpack-常用插件有哪些" aria-label="Permalink to &quot;webpack 常用插件有哪些&quot;">​</a></h2><ul><li>cleanWebapckPlugin：清理 dist 目录</li><li>htmlWebpackPlugin：生成 html 文件，并自动引入打包后的 js 文件</li><li>copyWebpackPlugin：复制文件</li><li>miniCssExtractPlugin：将 css 文件单独打包</li></ul><h2 id="平时遇到问题-怎么解决的-或者学习途径" tabindex="-1">平时遇到问题，怎么解决的，或者学习途径 <a class="header-anchor" href="#平时遇到问题-怎么解决的-或者学习途径" aria-label="Permalink to &quot;平时遇到问题，怎么解决的，或者学习途径&quot;">​</a></h2><p>掘金，知乎，github，百度，stackoverflow</p><h2 id="vue-和-react-的区别" tabindex="-1">vue 和 react 的区别 <a class="header-anchor" href="#vue-和-react-的区别" aria-label="Permalink to &quot;vue 和 react 的区别&quot;">​</a></h2><h2 id="有没有遇过跨端适配的问题" tabindex="-1">有没有遇过跨端适配的问题 <a class="header-anchor" href="#有没有遇过跨端适配的问题" aria-label="Permalink to &quot;有没有遇过跨端适配的问题&quot;">​</a></h2><h2 id="taro2-到-taro3-的迁移" tabindex="-1">Taro2 到 Taro3 的迁移 <a class="header-anchor" href="#taro2-到-taro3-的迁移" aria-label="Permalink to &quot;Taro2 到 Taro3 的迁移&quot;">​</a></h2><p>Api 变化，组件变化，生命周期变化</p><h2 id="taro-有遇到过什么问题" tabindex="-1">Taro 有遇到过什么问题 <a class="header-anchor" href="#taro-有遇到过什么问题" aria-label="Permalink to &quot;Taro 有遇到过什么问题&quot;">​</a></h2><p>(Taro 常问)[<a href="https://blog.csdn.net/qq_29101285/article/details/138899851" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_29101285/article/details/138899851</a>]</p><h2 id="一百万条数据怎么处理" tabindex="-1">一百万条数据怎么处理 <a class="header-anchor" href="#一百万条数据怎么处理" aria-label="Permalink to &quot;一百万条数据怎么处理&quot;">​</a></h2><h2 id="断点续传" tabindex="-1">断点续传 <a class="header-anchor" href="#断点续传" aria-label="Permalink to &quot;断点续传&quot;">​</a></h2><h2 id="监控埋点" tabindex="-1">监控埋点 <a class="header-anchor" href="#监控埋点" aria-label="Permalink to &quot;监控埋点&quot;">​</a></h2>`,38),n=[o];function r(p,i,c,h,d,u){return s(),e("div",null,n)}const q=a(t,[["render",r]]);export{m as __pageData,q as default};
